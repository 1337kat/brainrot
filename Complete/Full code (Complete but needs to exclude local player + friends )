--============================================================
-- LIVE PLOT + ANIMAL + $/s SCANNER + ESP (Highest Only + Text)
--============================================================

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local RunService = game:GetService("RunService")

local Animals = require(ReplicatedStorage.Datas.Animals)
local Plots = Workspace:WaitForChild("Plots")
local Camera = Workspace.CurrentCamera

--============================================================
-- HELPERS: TEXT PARSING
--============================================================
local function cleaned(s: string): string
    s = s:gsub("<.->","")
    s = s:gsub("%s+","")
    return s:lower()
end

local function looksLikeRate(clean: string): boolean
    return clean:match("^%$[%d%.]+[kmb]?/s$") ~= nil
end

local function parseRate(clean: string): number
    local num, suf = clean:match("%$(%d+%.?%d*)([kmb]?)/s")
    num = tonumber(num) or 0
    if suf == "k" then num *= 1e3 end
    if suf == "m" then num *= 1e6 end
    if suf == "b" then num *= 1e9 end
    return num
end

local function formatRate(n: number?): string
    if not n then return "(rate not found)" end
    if n >= 1e9 then return string.format("$%.2fB/s", n/1e9) end
    if n >= 1e6 then return string.format("$%.2fM/s", n/1e6) end
    if n >= 1e3 then return string.format("$%.2fK/s", n/1e3) end
    return "$"..n.."/s"
end

--============================================================
-- OWNER / ANIMALS
--============================================================
local function getOwner(plot: Instance): string
    local sign = plot:FindFirstChild("PlotSign", true)
    if not sign then return "Empty Base" end

    local label = sign:FindFirstChildWhichIsA("TextLabel", true)
    if not label or not label.Text then return "Empty Base" end

    if label.Text == "Empty Base" or label.Text == "YOUR BASE" then
        return "Empty Base"
    end
    return label.Text
end

local function getAnimals(plot: Instance): {string}
    local list = {}
    for _, obj in ipairs(plot:GetDescendants()) do
        if obj:IsA("Model") and Animals[obj.Name] then
            list[#list+1] = obj.Name
        end
    end
    table.sort(list)
    return list
end

--============================================================
-- PLOT DETECTION (BY ANCESTRY)
--============================================================
local function findPlot(inst: Instance?): Instance?
    local cur = inst
    while cur and cur ~= Workspace do
        if cur.Parent == Plots then
            return cur
        end
        cur = cur.Parent
    end
    return nil
end

--============================================================
-- ANIMAL NAME FROM BILLBOARDGUI
--============================================================
local function extractAnimalName(rateLabel: Instance): string?
    local gui = rateLabel:FindFirstAncestorWhichIsA("BillboardGui")
    if not gui then return nil end

    local name
    for _, child in ipairs(gui:GetDescendants()) do
        local ok, txt = pcall(function() return child.Text end)
        if ok and type(txt) == "string" and txt ~= rateLabel.Text then
            if not txt:find("%$") then
                -- last non-money text under this GUI is taken as animal name
                name = txt
            end
        end
    end
    return name
end

--============================================================
-- GLOBAL STATE: PLOT RATES + LABEL INDEX
--============================================================

-- PlotRates[plot] = { [animalName] = { rate = number, label = TextLabel } }
local PlotRates: {[Instance]: {[string]: {rate: number, label: Instance}}} = {}

-- LabelIndex[label] = { plot = plotInstance, animal = animalName }
local LabelIndex: {[Instance]: {plot: Instance, animal: string}} = {}

--============================================================
-- UPDATE ROUTINES FOR LABELS
--============================================================

local function removeLabelMapping(label: Instance)
    local meta = LabelIndex[label]
    if not meta then return end

    local plot = meta.plot
    local animal = meta.animal

    if PlotRates[plot] and PlotRates[plot][animal] then
        PlotRates[plot][animal] = nil
        if next(PlotRates[plot]) == nil then
            PlotRates[plot] = nil
        end
    end

    LabelIndex[label] = nil
end

local function processLabel(label: Instance)
    -- read text
    local ok, txt = pcall(function() return label.Text end)
    if not ok or type(txt) ~= "string" then
        removeLabelMapping(label)
        return
    end

    local clean = cleaned(txt)

    -- if it no longer looks like a /s rate, drop any mapping
    if not looksLikeRate(clean) then
        removeLabelMapping(label)
        return
    end

    -- looks like $/s, try to attach it
    local plot = findPlot(label)
    if not plot then
        removeLabelMapping(label)
        return
    end

    local animalName = extractAnimalName(label)
    if not animalName or animalName == "" then
        removeLabelMapping(label)
        return
    end

    local rate = parseRate(clean)

    PlotRates[plot] = PlotRates[plot] or {}
    PlotRates[plot][animalName] = { rate = rate, label = label }
    LabelIndex[label] = { plot = plot, animal = animalName }
end

--============================================================
-- INITIAL SCAN + WIRING EVENTS
--============================================================

-- check a new instance if it might be a TextLabel with $/s
local function tryHookLabelCandidate(inst: Instance)
    -- quick cheap check: try reading Text; if fails, ignore
    local ok, _ = pcall(function() return inst.Text end)
    if not ok then return end

    -- we know it has a Text property, so process it
    processLabel(inst)

    -- also track future changes to its Text
    inst:GetPropertyChangedSignal("Text"):Connect(function()
        processLabel(inst)
    end)
end

-- initial sweep
for _, obj in ipairs(Workspace:GetDescendants()) do
    tryHookLabelCandidate(obj)
end

-- live updates: new descendants
Workspace.DescendantAdded:Connect(function(inst)
    tryHookLabelCandidate(inst)
end)

-- live updates: removed descendants
Workspace.DescendantRemoving:Connect(function(inst)
    -- if a rate label is removed, clean up its mapping
    if LabelIndex[inst] then
        removeLabelMapping(inst)
    end
end)

--============================================================
-- PRINT SNAPSHOT (OPTIONAL)
--============================================================
local function printPlotInfo(plot: Instance)
    print("────────────────────────────")
    print("Plot:", plot.Name)
    print("Owner:", getOwner(plot))

    local animals = getAnimals(plot)
    if #animals == 0 then
        print("Animals: none")
        return
    end

    print("Animals + Rates:")
    local map = PlotRates[plot] or {}
    for _, name in ipairs(animals) do
        local info = map[name]
        local r = info and info.rate
        print((" • %s (%s)"):format(name, formatRate(r)))
    end
end

for _, plot in ipairs(Plots:GetChildren()) do
    printPlotInfo(plot)
end

print("[Live Plot+Animal+$Rate+ESP System] Active.")

--============================================================
-- ESP: CIRCLE + $/s TEXT FOR GLOBAL HIGHEST
--============================================================

local Circle = Drawing.new("Circle")
Circle.Thickness = 2
Circle.Color = Color3.fromRGB(0, 255, 0)
Circle.Filled = false
Circle.NumSides = 32
Circle.Radius = 30
Circle.Visible = false

local RateText = Drawing.new("Text")
RateText.Color = Color3.fromRGB(255, 255, 255)
RateText.Size = 18
RateText.Center = true
RateText.Outline = true
RateText.Visible = false

local function findAnimalModel(plot: Instance, name: string)
    for _, obj in ipairs(plot:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == name then
            local root = obj:FindFirstChild("HumanoidRootPart")
                or obj:FindFirstChild("Root")
                or obj:FindFirstChild("Head")
                or obj.PrimaryPart
            return obj, root
        end
    end
    return nil
end

local function findGlobalHighest()
    local bestPlot, bestName, bestInfo
    for plot, map in pairs(PlotRates) do
        for name, info in pairs(map) do
            if (not bestInfo) or info.rate > bestInfo.rate then
                bestPlot, bestName, bestInfo = plot, name, info
            end
        end
    end
    return bestPlot, bestName, bestInfo
end

RunService.RenderStepped:Connect(function()
    -- pick current highest /s globally
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    if not bestPlot or not bestName or not bestInfo then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    local pos, onScreen = Camera:WorldToViewportPoint(root.Position)
    if not onScreen then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    -- position + radius
    Circle.Visible = true
    Circle.Position = Vector2.new(pos.X, pos.Y)
    Circle.Radius = math.clamp(320 / math.max(pos.Z, 1), 14, 42)

    RateText.Visible = true
    RateText.Text = formatRate(bestInfo.rate)
    RateText.Position = Vector2.new(pos.X, pos.Y - Circle.Radius - 12)
end)
