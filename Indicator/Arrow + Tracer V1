--============================================================
-- THREAD #2 — FULL LIVE PLOT + ANIMAL + $/s SCANNER + ESP
-- WITH PROFESSIONAL FOZ HUD + YOUR BASE ESP (WHITE)
-- WITH INDUSTRY STANDARD FOZ TRACER (ON-SCREEN)
-- WITH PREMIUM FORTNITE-STYLE FOZ ARROW (OFF-SCREEN)
-- PLUS LOOK-ONLY VISIBILITY CULLING
--============================================================

task.spawn(function()

--============================================================
-- SERVICES
--============================================================
local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")

local Animals     = require(ReplicatedStorage.Datas.Animals)
local Plots       = Workspace:WaitForChild("Plots")
local Camera      = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

--============================================================
-- TEXT PARSING / RATE HELPERS
--============================================================
local function cleaned(s)
    s = s:gsub("<.->","")
    s = s:gsub("%s+","")
    return s:lower()
end

local function looksLikeRate(clean)
    return clean:match("^%$[%d%.]+[kmb]?/s$") ~= nil
end

local function parseRate(clean)
    local num, suf = clean:match("%$(%d+%.?%d*)([kmb]?)/s")
    num = tonumber(num) or 0
    if suf == "k" then num *= 1e3 end
    if suf == "m" then num *= 1e6 end
    if suf == "b" then num *= 1e9 end
    return num
end

local function formatRate(n)
    if not n then return "(rate not found)" end
    if n >= 1e9 then return string.format("$%dB/s", math.floor(n/1e9)) end
    if n >= 1e6 then return string.format("$%dM/s", math.floor(n/1e6)) end
    if n >= 1e3 then return string.format("$%dK/s", math.floor(n/1e3)) end
    return string.format("$%d/s", math.floor(n))
end

--============================================================
-- OWNER / ANIMAL DETECTION
--============================================================
local function getOwner(plot)
    local sign = plot:FindFirstChild("PlotSign", true)
    if not sign then return "Empty Base" end

    local lbl = sign:FindFirstChildWhichIsA("TextLabel", true)
    if not lbl or not lbl.Text then return "Empty Base" end
    local t = lbl.Text

    if t == "Empty Base" or t == "YOUR BASE" then return "Empty Base" end
    return t
end

local function getAnimals(plot)
    local list = {}
    for _, o in ipairs(plot:GetDescendants()) do
        if o:IsA("Model") and Animals[o.Name] then
            list[#list+1] = o.Name
        end
    end
    table.sort(list)
    return list
end

--============================================================
-- PLOT FINDER FOR LABELS
--============================================================
local function findPlot(inst)
    local cur = inst
    while cur and cur ~= Workspace do
        if cur.Parent == Plots then
            return cur
        end
        cur = cur.Parent
    end
    return nil
end

--============================================================
-- EXTRACT ANIMAL NAME FROM BILLBOARD GUI
--============================================================
local function extractAnimalName(rateLabel)
    local gui = rateLabel:FindFirstAncestorWhichIsA("BillboardGui")
    if not gui then return nil end

    local name
    for _, c in ipairs(gui:GetDescendants()) do
        local ok, txt = pcall(function() return c.Text end)
        if ok and type(txt) == "string"
            and txt ~= rateLabel.Text
            and not txt:find("%$")
        then
            name = txt
        end
    end
    return name
end

--============================================================
-- GLOBAL STATE (RATES)
--============================================================
local PlotRates  = {}  -- PlotRates[plot][animal] = {rate=number, label=TextLabel}
local LabelIndex = {}  -- LabelIndex[label] = {plot=plot, animal=name}

--============================================================
-- LABEL PROCESSOR (SHARED)
--============================================================
local function removeLabelMapping(lbl)
    local meta = LabelIndex[lbl]
    if not meta then return end

    local plot = meta.plot
    local anim = meta.animal

    if PlotRates[plot] and PlotRates[plot][anim] then
        PlotRates[plot][anim] = nil
        if not next(PlotRates[plot]) then
            PlotRates[plot] = nil
        end
    end

    LabelIndex[lbl] = nil
end

local function processLabel(lbl)
    local ok, txt = pcall(function() return lbl.Text end)
    if not ok or type(txt) ~= "string" then
        return removeLabelMapping(lbl)
    end

    local clean = cleaned(txt)
    if not looksLikeRate(clean) then
        return removeLabelMapping(lbl)
    end

    local plot = findPlot(lbl)
    if not plot then
        return removeLabelMapping(lbl)
    end

    local animal = extractAnimalName(lbl)
    if not animal then
        return removeLabelMapping(lbl)
    end

    local rate = parseRate(clean)

    PlotRates[plot] = PlotRates[plot] or {}
    PlotRates[plot][animal] = { rate = rate, label = lbl }
    LabelIndex[lbl] = { plot = plot, animal = animal }
end

--============================================================
-- HOOK LABELS
--============================================================
local function tryHookLabel(inst)
    local ok = pcall(function() return inst.Text end)
    if not ok then return end

    processLabel(inst)

    inst:GetPropertyChangedSignal("Text"):Connect(function()
        processLabel(inst)
    end)
end

for _, inst in ipairs(Workspace:GetDescendants()) do
    tryHookLabel(inst)
end

Workspace.DescendantAdded:Connect(tryHookLabel)
Workspace.DescendantRemoving:Connect(function(inst)
    if LabelIndex[inst] then
        removeLabelMapping(inst)
    end
end)

--============================================================
-- DEBUG PRINT INITIAL
--============================================================
local function printPlotInfo(plot)
    print("────────────────────────────")
    print("Plot:", plot.Name)
    print("Owner:", getOwner(plot))

    local animals = getAnimals(plot)
    if #animals == 0 then
        print("Animals: none")
        return
    end

    print("Animals + Rates:")
    local map = PlotRates[plot] or {}
    for _, nm in ipairs(animals) do
        local info = map[nm]
        local r = info and info.rate
        print((" • %s (%s)"):format(nm, formatRate(r)))
    end
end

for _, plot in ipairs(Plots:GetChildren()) do
    printPlotInfo(plot)
end

print("[Live Plot+Animal+$Rate+ESP System] Active.")

--============================================================
-- FIND GLOBAL HIGHEST
--============================================================
local function findAnimalModel(plot, name)
    for _, obj in ipairs(plot:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == name then
            local root =
                obj:FindFirstChild("HumanoidRootPart") or
                obj:FindFirstChild("Root") or
                obj:FindFirstChild("Head") or
                obj.PrimaryPart
            return obj, root
        end
    end
end

local function findGlobalHighest()
    local bestPlot, bestName, bestInfo

    for plot, map in pairs(PlotRates) do
        for name, info in pairs(map) do
            if not bestInfo or info.rate > bestInfo.rate then
                bestPlot, bestName, bestInfo = plot, name, info
            end
        end
    end

    return bestPlot, bestName, bestInfo
end

--============================================================
-- VISIBILITY CULLING (LOOK-ONLY)
--============================================================
local function isInFOV(worldPos, margin)
    margin = margin or 0
    local vp = Camera:WorldToViewportPoint(worldPos)
    local scr = Camera.ViewportSize
    local onScr = vp.Z > 0
        and vp.X >= -margin and vp.X <= scr.X + margin
        and vp.Y >= -margin and vp.Y <= scr.Y + margin

    return onScr, Vector2.new(vp.X, vp.Y), vp.Z
end

--============================================================
-- HIGHLIGHT RING + RATE TEXT (ON-SCREEN ONLY)
--============================================================
local Circle = Drawing.new("Circle")
Circle.Thickness = 2
Circle.Color = Color3.fromRGB(0, 255, 0)
Circle.Filled = false
Circle.NumSides = 32
Circle.Visible = false

local RateText = Drawing.new("Text")
RateText.Color = Color3.fromRGB(255, 255, 255)
RateText.Size = 18
RateText.Center = true
RateText.Outline = true
RateText.Visible = false

RunService.RenderStepped:Connect(function()
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    if not bestInfo then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    local onScreen, pos2, depth = isInFOV(root.Position, 60)
    if not onScreen then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    Circle.Visible = true
    Circle.Position = pos2
    Circle.Radius = math.clamp(320 / math.max(depth, 1), 14, 42)

    RateText.Visible = true
    RateText.Text = formatRate(bestInfo.rate)
    RateText.Position = Vector2.new(pos2.X, pos2.Y - Circle.Radius - 12)
end)

--============================================================
-- FOZ HUD (CENTER TEXT)
--============================================================
local FOZ_HUD = Drawing.new("Text")
FOZ_HUD.Color = Color3.fromRGB(255, 255, 255)
FOZ_HUD.Size = 26
FOZ_HUD.Center = true
FOZ_HUD.Outline = true
FOZ_HUD.Visible = true

RunService.RenderStepped:Connect(function()
    local _, _, bestInfo = findGlobalHighest()

    if bestInfo then
        FOZ_HUD.Text = formatRate(bestInfo.rate)
    else
        FOZ_HUD.Text = "N/A"
    end

    FOZ_HUD.Position = Vector2.new(
        Camera.ViewportSize.X / 2,
        (Camera.ViewportSize.Y / 2) - (Camera.ViewportSize.Y * 0.10)
    )
end)

--============================================================
-- INDUSTRY STANDARD FOZ TRACER (ON-SCREEN ONLY, FADE)
--============================================================
local TracerMain = Drawing.new("Line")
local TracerGlow = Drawing.new("Line")
local EndDot     = Drawing.new("Circle")

TracerMain.Visible = false
TracerGlow.Visible = false
EndDot.Visible     = false

TracerGlow.Transparency = 0.25
EndDot.Filled = true
EndDot.Color  = Color3.fromRGB(120, 255, 120)

local FADE_SPEED   = 0.18
local currentAlpha = 0

RunService.RenderStepped:Connect(function()
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    if not bestInfo then
        currentAlpha = math.max(0, currentAlpha - FADE_SPEED)
    else
        currentAlpha = math.min(1, currentAlpha + FADE_SPEED)
    end

    local a = currentAlpha
    TracerMain.Transparency = a
    TracerGlow.Transparency = 0.25 * a
    EndDot.Transparency     = a

    if a <= 0.01 then
        TracerMain.Visible = false
        TracerGlow.Visible = false
        EndDot.Visible     = false
        return
    end

    if not bestPlot or not bestName then return end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then return end

    local onScreen, animalPos = isInFOV(root.Position, 60)
    if not onScreen then
        -- off-screen => let Fortnite arrow handle, hide tracer
        TracerMain.Visible = false
        TracerGlow.Visible = false
        EndDot.Visible     = false
        return
    end

    local hudPos = FOZ_HUD.Position
    local dist   = (hudPos - animalPos).Magnitude
    local thick  = math.clamp(dist / 300, 1.8, 4)

    TracerMain.Visible   = true
    TracerMain.Color     = Color3.fromRGB(255, 255, 255)
    TracerMain.Thickness = thick
    TracerMain.From      = hudPos
    TracerMain.To        = animalPos

    TracerGlow.Visible   = true
    TracerGlow.Color     = Color3.fromRGB(120, 255, 120)
    TracerGlow.Thickness = thick * 2
    TracerGlow.From      = hudPos
    TracerGlow.To        = animalPos

    EndDot.Visible  = true
    EndDot.Position = animalPos
    EndDot.Radius   = math.clamp(5 + (thick * 0.8), 5, 12)
end)

--============================================================
-- ⭐ PREMIUM FORTNITE-STYLE FOZ ARROW (OFF-SCREEN ONLY)
--============================================================
local Arrow1 = Drawing.new("Line")
local Arrow2 = Drawing.new("Line")
local Arrow3 = Drawing.new("Line")

local ArrowGlow1 = Drawing.new("Line")
local ArrowGlow2 = Drawing.new("Line")
local ArrowGlow3 = Drawing.new("Line")

local function initArrowLine(L)
    L.Visible    = false
    L.Thickness  = 3
    L.Color      = Color3.fromRGB(255, 255, 255)
end

local function initGlowLine(L)
    L.Visible      = false
    L.Thickness    = 6
    L.Color        = Color3.fromRGB(255, 255, 255)
    L.Transparency = 0.35
end

for _, L in ipairs({Arrow1, Arrow2, Arrow3}) do
    initArrowLine(L)
end
for _, L in ipairs({ArrowGlow1, ArrowGlow2, ArrowGlow3}) do
    initGlowLine(L)
end

local function getRateColor(rate)
    if not rate then return Color3.fromRGB(255,255,255) end
    if rate >= 1e9 then return Color3.fromRGB(80, 255, 255) end   -- insane
    if rate >= 1e8 then return Color3.fromRGB(120, 255, 120) end  -- huge
    if rate >= 1e7 then return Color3.fromRGB(255, 230, 120) end  -- mid
    return Color3.fromRGB(255, 255, 255)
end

local pulsePhase = 0

RunService.RenderStepped:Connect(function(dt)
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    local function hideArrow()
        for _, L in ipairs({
            Arrow1, Arrow2, Arrow3,
            ArrowGlow1, ArrowGlow2, ArrowGlow3
        }) do
            L.Visible = false
        end
    end

    if not bestInfo or not bestPlot or not bestName then
        hideArrow()
        return
    end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then
        hideArrow()
        return
    end

    local cam    = Camera
    local screen = cam.ViewportSize
    local cx, cy = screen.X / 2, screen.Y / 2
    local center = Vector2.new(cx, cy)

    local vp = cam:WorldToViewportPoint(root.Position)
    local pos2 = Vector2.new(vp.X, vp.Y)

    -- On-screen? Then tracer/circle handle it; arrow hidden
    local isOnScreen =
        vp.Z > 0 and
        pos2.X >= 0 and pos2.X <= screen.X and
        pos2.Y >= 0 and pos2.Y <= screen.Y

    if isOnScreen then
        hideArrow()
        return
    end

    -- Behind camera? Flip through center for correct direction
    if vp.Z < 0 then
        pos2 = center - (pos2 - center)
    end

    local dir = pos2 - center
    if dir.Magnitude < 1 then
        dir = Vector2.new(0, -1)
    else
        dir = dir.Unit
    end

    local color = getRateColor(bestInfo.rate)

    ------------------------------------------------------------
    -- SCREEN EDGE INTERSECTION (MARGIN-CLAMPED)
    ------------------------------------------------------------
    local margin = 35
    local Lx = margin
    local Rx = screen.X - margin
    local Ty = margin
    local By = screen.Y - margin

    local tMin = math.huge
    local hitX, hitY

    -- left edge
    if dir.X ~= 0 then
        local tL = (Lx - cx) / dir.X
        local yL = cy + dir.Y * tL
        if tL > 0 and yL >= Ty and yL <= By and tL < tMin then
            tMin = tL
            hitX, hitY = Lx, yL
        end
    end

    -- right edge
    if dir.X ~= 0 then
        local tR = (Rx - cx) / dir.X
        local yR = cy + dir.Y * tR
        if tR > 0 and yR >= Ty and yR <= By and tR < tMin then
            tMin = tR
            hitX, hitY = Rx, yR
        end
    end

    -- top edge
    if dir.Y ~= 0 then
        local tT = (Ty - cy) / dir.Y
        local xT = cx + dir.X * tT
        if tT > 0 and xT >= Lx and xT <= Rx and tT < tMin then
            tMin = tT
            hitX, hitY = xT, Ty
        end
    end

    -- bottom edge
    if dir.Y ~= 0 then
        local tB = (By - cy) / dir.Y
        local xB = cx + dir.X * tB
        if tB > 0 and xB >= Lx and xB <= Rx and tB < tMin then
            tMin = tB
            hitX, hitY = xB, By
        end
    end

    if not hitX or not hitY then
        hideArrow()
        return
    end

    local tip = Vector2.new(hitX, hitY)

    ------------------------------------------------------------
    -- PREMIUM EFFECTS: PULSE + GLOW + RATE COLOR
    ------------------------------------------------------------
    pulsePhase = pulsePhase + (dt or 0.016) * 3
    local pulseScale = 0.9 + 0.15 * math.sin(pulsePhase)

    local baseSize   = 28
    local arrowSize  = baseSize * pulseScale
    local arrowWidth = (baseSize * 0.7) * pulseScale

    local base = tip - dir * arrowSize
    local perp = Vector2.new(-dir.Y, dir.X)

    local left  = base + perp * (arrowWidth / 2)
    local right = base - perp * (arrowWidth / 2)

    -- main triangle
    Arrow1.Visible = true
    Arrow2.Visible = true
    Arrow3.Visible = true

    Arrow1.Color = color
    Arrow2.Color = color
    Arrow3.Color = color

    Arrow1.From = tip
    Arrow1.To   = left

    Arrow2.From = tip
    Arrow2.To   = right

    Arrow3.From = left
    Arrow3.To   = right

    -- glow (slightly larger triangle)
    local glowTip   = tip
    local glowBase  = tip - dir * (arrowSize + 4)
    local glowLeft  = glowBase + perp * ((arrowWidth + 6) / 2)
    local glowRight = glowBase - perp * ((arrowWidth + 6) / 2)

    ArrowGlow1.Visible = true
    ArrowGlow2.Visible = true
    ArrowGlow3.Visible = true

    ArrowGlow1.Color = color
    ArrowGlow2.Color = color
    ArrowGlow3.Color = color

    ArrowGlow1.From = glowTip
    ArrowGlow1.To   = glowLeft

    ArrowGlow2.From = glowTip
    ArrowGlow2.To   = glowRight

    ArrowGlow3.From = glowLeft
    ArrowGlow3.To   = glowRight
end)

--============================================================
-- YOUR BASE ESP (WHITE, LOOK-FORWARD, ON-SCREEN ONLY)
--============================================================
local TEXT_FORWARD = 29
local TEXT_RIGHT   = 0
local TEXT_UP      = 7

local BaseText = Drawing.new("Text")
BaseText.Visible = false
BaseText.Center  = true
BaseText.Size    = 25
BaseText.Font    = 2
BaseText.Outline = true
BaseText.Color   = Color3.fromRGB(255, 255, 255)
BaseText.Text    = "YOUR BASE"
pcall(function()
    BaseText.OutlineColor = Color3.new(0, 0, 0)
end)

local function findMyPlot()
    for _, plot in ipairs(Plots:GetChildren()) do
        local sign = plot:FindFirstChild("PlotSign")
        local gui  = sign and sign:FindFirstChild("SurfaceGui")
        local fr   = gui and gui:FindFirstChild("Frame")
        local lbl  = fr and fr:FindFirstChildWhichIsA("TextLabel")
        if lbl and lbl.Text then
            if lbl.Text == LocalPlayer.Name or lbl.Text == LocalPlayer.DisplayName
            or lbl.Text:find(LocalPlayer.Name)
            or lbl.Text:find(LocalPlayer.DisplayName) then
                return plot
            end
        end
    end
end

local MyPlot = findMyPlot()

local function getAnchor(plot)
    if not plot then return end
    for _, o in ipairs(plot:GetDescendants()) do
        if o:IsA("BasePart") then
            return o
        end
    end
end

local Anchor = getAnchor(MyPlot)

RunService.RenderStepped:Connect(function()
    if not Anchor or not Anchor.Parent then
        MyPlot = findMyPlot()
        Anchor = getAnchor(MyPlot)
        if not Anchor then
            BaseText.Visible = false
            return
        end
    end

    local cf = Anchor.CFrame
    local pos3 =
        Anchor.Position +
        cf.LookVector * TEXT_FORWARD +
        cf.RightVector * TEXT_RIGHT +
        cf.UpVector * TEXT_UP

    local onScreen, pos2 = isInFOV(pos3, 30)
    BaseText.Visible = onScreen
    if onScreen then
        BaseText.Position = pos2
    end
end)

end)
