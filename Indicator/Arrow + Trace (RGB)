task.spawn(function()

local Players           = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace         = game:GetService("Workspace")
local RunService        = game:GetService("RunService")

local Animals     = require(ReplicatedStorage.Datas.Animals)
local Plots       = Workspace:WaitForChild("Plots")
local Camera      = Workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

local function cleaned(s)
    s = s:gsub("<.->","")
    s = s:gsub("%s+","")
    return s:lower()
end

local function looksLikeRate(clean)
    return clean:match("^%$[%d%.]+[kmb]?/s$") ~= nil
end

local function parseRate(clean)
    local num, suf = clean:match("%$(%d+%.?%d*)([kmb]?)/s")
    num = tonumber(num) or 0
    if suf == "k" then num *= 1e3 end
    if suf == "m" then num *= 1e6 end
    if suf == "b" then num *= 1e9 end
    return num
end

local function formatRate(n)
    if not n then return "(rate not found)" end
    if n >= 1e9 then return string.format("$%dB/s", math.floor(n/1e9)) end
    if n >= 1e6 then return string.format("$%dM/s", math.floor(n/1e6)) end
    if n >= 1e3 then return string.format("$%dK/s", math.floor(n/1e3)) end
    return string.format("$%d/s", math.floor(n))
end

local function getOwner(plot)
    local sign = plot:FindFirstChild("PlotSign", true)
    if not sign then return "Empty Base" end

    local lbl = sign:FindFirstChildWhichIsA("TextLabel", true)
    if not lbl or not lbl.Text then return "Empty Base" end
    local t = lbl.Text

    if t == "Empty Base" or t == "YOUR BASE" then return "Empty Base" end
    return t
end

local function getAnimals(plot)
    local list = {}
    for _, o in ipairs(plot:GetDescendants()) do
        if o:IsA("Model") and Animals[o.Name] then
            list[#list+1] = o.Name
        end
    end
    table.sort(list)
    return list
end

local function findPlot(inst)
    local cur = inst
    while cur and cur ~= Workspace do
        if cur.Parent == Plots then
            return cur
        end
        cur = cur.Parent
    end
    return nil
end

local function extractAnimalName(rateLabel)
    local gui = rateLabel:FindFirstAncestorWhichIsA("BillboardGui")
    if not gui then return nil end

    local name
    for _, c in ipairs(gui:GetDescendants()) do
        local ok, txt = pcall(function() return c.Text end)
        if ok and type(txt) == "string"
            and txt ~= rateLabel.Text
            and not txt:find("%$")
        then
            name = txt
        end
    end
    return name
end

local PlotRates  = {}  
local LabelIndex = {}  

local function removeLabelMapping(lbl)
    local meta = LabelIndex[lbl]
    if not meta then return end

    local plot = meta.plot
    local anim = meta.animal

    if PlotRates[plot] and PlotRates[plot][anim] then
        PlotRates[plot][anim] = nil
        if not next(PlotRates[plot]) then
            PlotRates[plot] = nil
        end
    end

    LabelIndex[lbl] = nil
end

local function processLabel(lbl)
    local ok, txt = pcall(function() return lbl.Text end)
    if not ok or type(txt) ~= "string" then
        return removeLabelMapping(lbl)
    end

    local clean = cleaned(txt)
    if not looksLikeRate(clean) then
        return removeLabelMapping(lbl)
    end

    local plot = findPlot(lbl)
    if not plot then
        return removeLabelMapping(lbl)
    end

    local animal = extractAnimalName(lbl)
    if not animal then
        return removeLabelMapping(lbl)
    end

    local rate = parseRate(clean)

    PlotRates[plot] = PlotRates[plot] or {}
    PlotRates[plot][animal] = { rate = rate, label = lbl }
    LabelIndex[lbl] = { plot = plot, animal = animal }
end

local function tryHookLabel(inst)
    local ok = pcall(function() return inst.Text end)
    if not ok then return end

    processLabel(inst)

    inst:GetPropertyChangedSignal("Text"):Connect(function()
        processLabel(inst)
    end)
end

for _, inst in ipairs(Workspace:GetDescendants()) do
    tryHookLabel(inst)
end

Workspace.DescendantAdded:Connect(tryHookLabel)
Workspace.DescendantRemoving:Connect(function(inst)
    if LabelIndex[inst] then
        removeLabelMapping(inst)
    end
end)

local function printPlotInfo(plot)
    print("────────────────────────────")
    print("Plot:", plot.Name)
    print("Owner:", getOwner(plot))

    local animals = getAnimals(plot)
    if #animals == 0 then
        print("Animals: none")
        return
    end

    print("Animals + Rates:")
    local map = PlotRates[plot] or {}
    for _, nm in ipairs(animals) do
        local info = map[nm]
        local r = info and info.rate
        print((" • %s (%s)"):format(nm, formatRate(r)))
    end
end

for _, plot in ipairs(Plots:GetChildren()) do
    printPlotInfo(plot)
end

print("[Live Plot+Animal+$Rate+ESP System] Active.")

local function findAnimalModel(plot, name)
    for _, obj in ipairs(plot:GetDescendants()) do
        if obj:IsA("Model") and obj.Name == name then
            local root =
                obj:FindFirstChild("HumanoidRootPart") or
                obj:FindFirstChild("Root") or
                obj:FindFirstChild("Head") or
                obj.PrimaryPart
            return obj, root
        end
    end
end

local function findGlobalHighest()
    local bestPlot, bestName, bestInfo

    for plot, map in pairs(PlotRates) do
        for name, info in pairs(map) do
            if not bestInfo or info.rate > bestInfo.rate then
                bestPlot, bestName, bestInfo = plot, name, info
            end
        end
    end

    return bestPlot, bestName, bestInfo
end

local function isInFOV(worldPos, margin)
    margin = margin or 0
    local vp = Camera:WorldToViewportPoint(worldPos)
    local scr = Camera.ViewportSize
    local onScr = vp.Z > 0
        and vp.X >= -margin and vp.X <= scr.X + margin
        and vp.Y >= -margin and vp.Y <= scr.Y + margin

    return onScr, Vector2.new(vp.X, vp.Y), vp.Z
end

local Circle = Drawing.new("Circle")
Circle.Thickness = 2
Circle.Color = Color3.fromRGB(0, 255, 0)
Circle.Filled = false
Circle.NumSides = 32
Circle.Visible = false

local RateText = Drawing.new("Text")
RateText.Color = Color3.fromRGB(255, 255, 255)
RateText.Size = 18
RateText.Center = true
RateText.Outline = true
RateText.Visible = false

RunService.RenderStepped:Connect(function()
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    if not bestInfo then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    local onScreen, pos2, depth = isInFOV(root.Position, 60)
    if not onScreen then
        Circle.Visible = false
        RateText.Visible = false
        return
    end

    Circle.Visible = true
    Circle.Position = pos2
    Circle.Radius = math.clamp(320 / math.max(depth, 1), 14, 42)

    RateText.Visible = true
    RateText.Text = formatRate(bestInfo.rate)
    RateText.Position = Vector2.new(pos2.X, pos2.Y - Circle.Radius - 12)
end)

local FOZ_HUD = Drawing.new("Text")
FOZ_HUD.Color = Color3.fromRGB(255, 255, 255)
FOZ_HUD.Size = 26
FOZ_HUD.Center = true
FOZ_HUD.Outline = true
FOZ_HUD.Visible = true

RunService.RenderStepped:Connect(function()
    local _, _, bestInfo = findGlobalHighest()

    if bestInfo then
        FOZ_HUD.Text = formatRate(bestInfo.rate)
    else
        FOZ_HUD.Text = "N/A"
    end

    FOZ_HUD.Position = Vector2.new(
        Camera.ViewportSize.X / 2,
        (Camera.ViewportSize.Y / 2) - (Camera.ViewportSize.Y * 0.10)
    )
end)

local TracerMain = Drawing.new("Line")
local TracerGlow = Drawing.new("Line")
local EndDot     = Drawing.new("Circle")

TracerMain.Visible = false
TracerGlow.Visible = false
EndDot.Visible     = false

TracerGlow.Transparency = 0.25
EndDot.Filled = true
EndDot.Color  = Color3.fromRGB(120, 255, 120)

local FADE_SPEED   = 0.18
local currentAlpha = 0

RunService.RenderStepped:Connect(function()
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    if not bestInfo then
        currentAlpha = math.max(0, currentAlpha - FADE_SPEED)
    else
        currentAlpha = math.min(1, currentAlpha + FADE_SPEED)
    end

    local a = currentAlpha
    TracerMain.Transparency = a
    TracerGlow.Transparency = 0.25 * a
    EndDot.Transparency     = a

    if a <= 0.01 then
        TracerMain.Visible = false
        TracerGlow.Visible = false
        EndDot.Visible     = false
        return
    end

    if not bestPlot or not bestName then return end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then return end

    local onScreen, animalPos = isInFOV(root.Position, 60)
    if not onScreen then
        TracerMain.Visible = false
        TracerGlow.Visible = false
        EndDot.Visible     = false
        return
    end

    local hudPos = FOZ_HUD.Position
    local dist   = (hudPos - animalPos).Magnitude
    local thick  = math.clamp(dist / 300, 1.8, 4)

    TracerMain.Visible   = true
    TracerMain.Color     = Color3.fromRGB(255, 255, 255)
    TracerMain.Thickness = thick
    TracerMain.From      = hudPos
    TracerMain.To        = animalPos

    TracerGlow.Visible   = true
    TracerGlow.Color     = Color3.fromRGB(120, 255, 120)
    TracerGlow.Thickness = thick * 2
    TracerGlow.From      = hudPos
    TracerGlow.To        = animalPos

    EndDot.Visible  = true
    EndDot.Position = animalPos
    EndDot.Radius   = math.clamp(5 + (thick * 0.8), 5, 12)
end)

-- ========================================
-- ENHANCED ARROW: MASSIVE + RGB + FLASH + PULSE
-- LOGIC 100% PRESERVED
-- ========================================
local Arrow1 = Drawing.new("Line")
local Arrow2 = Drawing.new("Line")
local Arrow3 = Drawing.new("Line")

local ArrowGlow1 = Drawing.new("Line")
local ArrowGlow2 = Drawing.new("Line")
local ArrowGlow3 = Drawing.new("Line")

-- Main arrow: bold, rate-colored
for _, L in ipairs({Arrow1, Arrow2, Arrow3}) do
    L.Visible = false
    L.Thickness = 5
end

-- Glow arrow: massive, RGB cycling
for _, L in ipairs({ArrowGlow1, ArrowGlow2, ArrowGlow3}) do
    L.Visible = false
    L.Thickness = 13
    L.Transparency = 0.6
end

local function getRateColor(rate)
    if not rate then return Color3.fromRGB(255,255,255) end
    if rate >= 1e9 then return Color3.fromRGB(80, 255, 255) end   
    if rate >= 1e8 then return Color3.fromRGB(120, 255, 120) end  
    if rate >= 1e7 then return Color3.fromRGB(255, 230, 120) end  
    return Color3.fromRGB(255, 255, 255)
end

local pulsePhase = 0
local rgbPhase = 0
local flashPhase = 0

RunService.RenderStepped:Connect(function(dt)
    local bestPlot, bestName, bestInfo = findGlobalHighest()

    local function hideArrow()
        for _, L in ipairs({Arrow1, Arrow2, Arrow3, ArrowGlow1, ArrowGlow2, ArrowGlow3}) do
            L.Visible = false
        end
    end

    if not bestInfo or not bestPlot or not bestName then
        hideArrow()
        return
    end

    local model, root = findAnimalModel(bestPlot, bestName)
    if not root then
        hideArrow()
        return
    end

    local cam    = Camera
    local screen = cam.ViewportSize
    local cx, cy = screen.X / 2, screen.Y / 2
    local center = Vector2.new(cx, cy)

    local vp = cam:WorldToViewportPoint(root.Position)
    local pos2 = Vector2.new(vp.X, vp.Y)

    local isOnScreen =
        vp.Z > 0 and
        pos2.X >= 0 and pos2.X <= screen.X and
        pos2.Y >= 0 and pos2.Y <= screen.Y

    if isOnScreen then
        hideArrow()
        return
    end

    if vp.Z < 0 then
        pos2 = center - (pos2 - center)
    end

    local dir = pos2 - center
    if dir.Magnitude < 1 then
        dir = Vector2.new(0, -1)
    else
        dir = dir.Unit
    end

    local color = getRateColor(bestInfo.rate)

    local margin = 35
    local Lx = margin
    local Rx = screen.X - margin
    local Ty = margin
    local By = screen.Y - margin

    local tMin = math.huge
    local hitX, hitY

    if dir.X ~= 0 then
        local tL = (Lx - cx) / dir.X
        local yL = cy + dir.Y * tL
        if tL > 0 and yL >= Ty and yL <= By and tL < tMin then
            tMin = tL
            hitX, hitY = Lx, yL
        end
    end

    if dir.X ~= 0 then
        local tR = (Rx - cx) / dir.X
        local yR = cy + dir.Y * tR
        if tR > 0 and yR >= Ty and yR <= By and tR < tMin then
            tMin = tR
            hitX, hitY = Rx, yR
        end
    end

    if dir.Y ~= 0 then
        local tT = (Ty - cy) / dir.Y
        local xT = cx + dir.X * tT
        if tT > 0 and xT >= Lx and xT <= Rx and tT < tMin then
            tMin = tT
            hitX, hitY = xT, Ty
        end
    end

    if dir.Y ~= 0 then
        local tB = (By - cy) / dir.Y
        local xB = cx + dir.X * tB
        if tB > 0 and xB >= Lx and xB <= Rx and tB < tMin then
            tMin = tB
            hitX, hitY = xB, By
        end
    end

    if not hitX or not hitY then
        hideArrow()
        return
    end

    local tip = Vector2.new(hitX, hitY)

    -- === PULSE + FLASH + RGB CYCLE ===
    pulsePhase = pulsePhase + (dt or 0.016) * 3.5
    rgbPhase = rgbPhase + (dt or 0.016) * 1.8
    flashPhase = flashPhase + (dt or 0.016) * 7

    local pulseScale = 0.85 + 0.25 * math.sin(pulsePhase)
    local flash = (math.sin(flashPhase) > 0.6) and 1 or 0.7

    -- === MASSIVE ARROW ===
    local baseSize   = 44
    local arrowSize  = baseSize * pulseScale
    local arrowWidth = (baseSize * 0.7) * pulseScale

    local base = tip - dir * arrowSize
    local perp = Vector2.new(-dir.Y, dir.X)

    local left  = base + perp * (arrowWidth / 2)
    local right = base - perp * (arrowWidth / 2)

    -- Main Arrow
    Arrow1.Visible = true; Arrow2.Visible = true; Arrow3.Visible = true
    Arrow1.Color = color; Arrow2.Color = color; Arrow3.Color = color

    Arrow1.From = tip; Arrow1.To = left
    Arrow2.From = tip; Arrow2.To = right
    Arrow3.From = left; Arrow3.To = right

    -- === RGB GLOW (MASSIVE + FLASHING) ===
    local glowSize = arrowSize + 12
    local glowWidth = arrowWidth + 14

    local glowBase  = tip - dir * glowSize
    local glowLeft  = glowBase + perp * (glowWidth / 2)
    local glowRight = glowBase - perp * (glowWidth / 2)

    local hue = (rgbPhase % 1)
    local rgbColor = Color3.fromHSV(hue, 1, 1)

    ArrowGlow1.Visible = true; ArrowGlow2.Visible = true; ArrowGlow3.Visible = true
    ArrowGlow1.Color = rgbColor; ArrowGlow2.Color = rgbColor; ArrowGlow3.Color = rgbColor
    ArrowGlow1.Transparency = 0.6 * flash
    ArrowGlow2.Transparency = 0.6 * flash
    ArrowGlow3.Transparency = 0.6 * flash

    ArrowGlow1.From = tip; ArrowGlow1.To = glowLeft
    ArrowGlow2.From = tip; ArrowGlow2.To = glowRight
    ArrowGlow3.From = glowLeft; ArrowGlow3.To = glowRight
end)

local TEXT_FORWARD = 29
local TEXT_RIGHT   = 0
local TEXT_UP      = 7

local BaseText = Drawing.new("Text")
BaseText.Visible = false
BaseText.Center  = true
BaseText.Size    = 25
BaseText.Font    = 2
BaseText.Outline = true
BaseText.Color   = Color3.fromRGB(255, 255, 255)
BaseText.Text    = "YOUR BASE"
pcall(function()
    BaseText.OutlineColor = Color3.new(0, 0, 0)
end)

local function findMyPlot()
    for _, plot in ipairs(Plots:GetChildren()) do
        local sign = plot:FindFirstChild("PlotSign")
        local gui  = sign and sign:FindFirstChild("SurfaceGui")
        local fr   = gui and gui:FindFirstChild("Frame")
        local lbl  = fr and fr:FindFirstChildWhichIsA("TextLabel")
        if lbl and lbl.Text then
            if lbl.Text == LocalPlayer.Name or lbl.Text == LocalPlayer.DisplayName
            or lbl.Text:find(LocalPlayer.Name)
            or lbl.Text:find(LocalPlayer.DisplayName) then
                return plot
            end
        end
    end
end

local MyPlot = findMyPlot()

local function getAnchor(plot)
    if not plot then return end
    for _, o in ipairs(plot:GetDescendants()) do
        if o:IsA("BasePart") then
            return o
        end
    end
end

local Anchor = getAnchor(MyPlot)

RunService.RenderStepped:Connect(function()
    if not Anchor or not Anchor.Parent then
        MyPlot = findMyPlot()
        Anchor = getAnchor(MyPlot)
        if not Anchor then
            BaseText.Visible = false
            return
        end
    end

    local cf = Anchor.CFrame
    local pos3 =
        Anchor.Position +
        cf.LookVector * TEXT_FORWARD +
        cf.RightVector * TEXT_RIGHT +
        cf.UpVector * TEXT_UP

    local onScreen, pos2 = isInFOV(pos3, 30)
    BaseText.Visible = onScreen
    if onScreen then
        BaseText.Position = pos2
    end
end)

end)
